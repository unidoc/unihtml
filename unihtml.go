//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package unihtml contains a plugin for the UniDoc.
package unihtml ;import (_bb "bytes";_f "context";_bd "errors";_g "fmt";_cge "github.com/unidoc/unihtml/client";_fb "github.com/unidoc/unihtml/content";_fd "github.com/unidoc/unihtml/selector";_e "github.com/unidoc/unihtml/sizes";_ef "github.com/unidoc/unipdf/v4/common";
_bgb "github.com/unidoc/unipdf/v4/common/license";_ca "github.com/unidoc/unipdf/v4/creator";_fa "github.com/unidoc/unipdf/v4/model";_ed "github.com/unidoc/unipdf/v4/render";_bf "image";_cg "image/color";_da "math";_b "net/url";_c "os";_bg "time";);func _eae ()error {_cd :=_bgb .GetLicenseKey ();
if _cd ==nil {return _bd .New ("\u006e\u006f\u0020\u006cic\u0065\u006e\u0073\u0065\u0020\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064");};if !_cd .IsLicensed (){return _bd .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0072 \u006e\u006f\u0020\u006c\u0069\u0063\u0065n\u0073\u0065\u0020\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064");
};return nil ;};

// Connect creates UniHTML HTTP Client and tries to establish connection with the server.
func Connect (path string )error {if _ec :=_eae ();_ec !=nil {return _ec ;};_fe ,_ba :=_cge .ParseOptions (path );if _ba !=nil {return _ba ;};_ff =_cge .New (_fe );_gd ,_ce :=_f .WithTimeout (_f .Background (),_bg .Second *5);defer _ce ();if _ea :=_ff .HealthCheck (_gd );
_ea !=nil {return _ea ;};return nil ;};

// SetMarginRight sets the left margin.
func (_ebd *Document )SetMarginRight (margin _e .Length ){_ebd ._a .Right =margin };

// GeneratePageBlocks implements creator.Drawable interface.
func (_bbg *Document )GeneratePageBlocks (ctx _ca .DrawContext )([]*_ca .Block ,_ca .DrawContext ,error ){if _ab :=_bbg .validate ();_ab !=nil {return nil ,ctx ,_ab ;};var _ee []*_ca .Block ;_gaf :=_bbg .getMargins ();_eaa ,_ffg :=_bbg ._cdd ,_bbg ._cf ;
if _bbg ._bfd .IsRelative (){_eaa ,_ffg =_e .Point (ctx .Width ),_e .Point (ctx .Height );ctx .X -=float64 (_gaf .Left .Points ());}else {ctx .X =_bbg ._ae ;ctx .Y =_bbg ._cgd ;};_ag ,_efe :=_bbg .extract (_f .Background (),_eaa ,_ffg ,_gaf );if _efe !=nil {return nil ,_ca .DrawContext {},_efe ;
};for _edg ,_cee :=range _ag {_faa ,_db :=_ca .NewBlockFromPage (_cee );if _db !=nil {return nil ,_ca .DrawContext {},_db ;};var _caf float64 ;if _bbg ._cddf &&_edg ==len (_ag )-1{_ggc :=_ed .NewImageDevice ();_cdg ,_gfa :=_ggc .Render (_cee );if _gfa !=nil {return nil ,_ca .DrawContext {},_gfa ;
};_gc ,_gfa :=_cee .GetMediaBox ();if _gfa !=nil {return nil ,_ca .DrawContext {},_gfa ;};_fef :=_bg .Now ();_gfae :=_eg (_cdg );_caf =_gc .Height ()*_gfae ;_ef .Log .Trace ("\u0054\u0072i\u006d\u006d\u0069\u006eg\u0020\u006ca\u0073\u0074\u0020\u0064\u006f\u0063\u0075\u006de\u006e\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0074\u0061\u006b\u0065n\u003a\u0020\u0025\u0076",_bg .Since (_fef ));
if _bbg ._a .Bottom !=nil {_caf -=float64 (_bbg ._a .Bottom .Points ());};if _caf < 0{_caf =0;};_ef .Log .Trace ("C\u0072\u006f\u0070\u0070\u0069\u006e\u0067\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0027\u0073\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u002e2\u0066 \u0070\u006f\u0069\u006et\u0073\u0020o\u0066\u0066\u0020\u0062\u006f\u0074\u0074\u006f\u006d\u0020\u006f\u0066\u0020\u006d\u0065\u0064\u0069\u0061\u0020\u0062\u006f\u0078\u000a",_caf );
};_af ,_abf ,_db :=_faa .GeneratePageBlocks (ctx );if _db !=nil {return nil ,_ca .DrawContext {},_db ;};ctx =_abf ;ctx .Y -=_caf ;if _edg !=len (_ag )-1&&ctx .Y > (ctx .PageHeight -ctx .Margins .Bottom )*.95{ctx .X =ctx .Margins .Left ;ctx .Y =ctx .Margins .Top ;
ctx .Page ++;};_ee =append (_ee ,_af ...);};return _ee ,ctx ,nil ;};func (_fad *Document )getTimeoutDuration ()_bg .Duration {if _fad ._ga !=nil {return *_fad ._ga ;};return 0;};

// Options are the HTML Client options used for establishing the connection.
type Options struct{

// Hostname defines the hostname for the client. Default value: 'localhost'.
Hostname string ;

// Port defines the port at which the server works. Default value: '8080'
Port int ;

// Secure is the flag that states if the connection uses HTTPS protocol. Default Value: 'false'.
Secure bool ;

// Prefix is an option setting used when the server is working with the URI prefix. Default Value: ''.
Prefix string ;};

// SetTimeoutDuration sets the timeout duration
// the default timeout is 15 seconds.
func (_cae *Document )SetTimeoutDuration (duration _bg .Duration ){_cae ._ga =&duration };

// SetLandscapeOrientation sets document landscape page orientation.
func (_ebf *Document )SetLandscapeOrientation (){_ebf ._cfa =_e .Landscape };

// ContainerComponent implements creator.containerElement interface.
func (_dcc *Document )ContainerComponent (container _ca .Drawable )(_ca .Drawable ,error ){switch container .(type ){case *_ca .Chapter :default:return nil ,_g .Errorf ("\u0075\u006e\u0069\u0068t\u006d\u006c\u002e\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0063\u006f\u006d\u0070\u006fn\u0065\u006e\u0074\u0020\u006ff\u0020\u0074\u0068\u0065\u0020\u0025\u0054\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072",container );
};return _dcc ,nil ;};

// GetContent returns the content of the document.
func (_fdb *Document )GetContent ()_fb .Content {return _fdb ._bag };

// NewDocumentFromString creates a new Document from the provided HTML string.
func NewDocumentFromString (html string )(*Document ,error ){_aef ,_cef :=_fb .NewStringContent (html );if _cef !=nil {return nil ,_cef ;};_eb :=&Document {};_eb ._bag =_aef ;return _eb ,nil ;};func (_eag *Document )getMargins ()margins {_dfa :=_eag ._a ;
if _eag ._bfd .IsRelative (){_dfa .Top =_e .Millimeter (1);_dfa .Left =_e .Millimeter (1);_dfa .Bottom =_e .Millimeter (1);_dfa .Right =_e .Millimeter (1);return _dfa ;};if _dfa .Top ==nil {_dfa .Top =_e .Millimeter (10);};if _dfa .Bottom ==nil {_dfa .Bottom =_e .Millimeter (10);
};if _dfa .Left ==nil {_dfa .Left =_e .Millimeter (10);};if _dfa .Right ==nil {_dfa .Right =_e .Millimeter (10);};return _dfa ;};var ErrNoClient =_bd .New ("\u0055n\u0069\u0048\u0054\u004d\u004c\u0020\u0063\u006c\u0069\u0065\u006et\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");


// SetPageHeight sets the page height for given document.
func (_cab *Document )SetPageHeight (pageHeight _e .Length )error {_cab ._cf =pageHeight ;_cab ._bfd =_ca .PositionAbsolute ;return nil ;};

// SetPageSize sets the page default size.
func (_bge *Document )SetPageSize (pageSize _e .PageSize )error {if !pageSize .IsAPageSize (){return _bd .New ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0070\u0061\u0067\u0065\u0020s\u0069\u007a\u0065");
};_bge ._eca =pageSize ;_bge ._bfd =_ca .PositionAbsolute ;return nil ;};

// GetPdfPages is a function that converts provided input content and
func (_cb *Document )GetPdfPages (ctx _f .Context )([]*_fa .PdfPage ,error ){if _dad :=_cb .validate ();_dad !=nil {return nil ,_dad ;};return _cb .extract (ctx ,_cb ._cdd ,_cb ._cf ,_cb .getMargins ());};func (_afg *Document )extract (_aa _f .Context ,_dgg ,_bgd _e .Length ,_aefe margins )([]*_fa .PdfPage ,error ){_dd :=_cge .BuildHTMLQuery ().SetContent (_afg ._bag ).PageSize (_afg ._eca ).PaperWidth (_dgg ).PaperHeight (_bgd ).Orientation (_afg ._cfa ).MarginLeft (_aefe .Left ).MarginRight (_aefe .Right ).MarginTop (_aefe .Top ).MarginBottom (_aefe .Bottom ).TimeoutDuration (_afg .getTimeoutDuration ()).WaitTime (_afg ._bfb );
for _ ,_efeb :=range _afg ._cga {_dd .WaitReady (_efeb .Selector ,_efeb .By );};for _ ,_cgac :=range _afg ._fg {_dd .WaitVisible (_cgac .Selector ,_cgac .By );};_fff ,_gac :=_dd .Query ();if _gac !=nil {return nil ,_gac ;};var _ffa _f .CancelFunc ;if _afg ._ga !=nil {_aa ,_ffa =_f .WithTimeout (_aa ,*_afg ._ga );
}else {_aa ,_ffa =_f .WithTimeout (_aa ,_bg .Second *15);};defer _ffa ();_fae ,_gac :=_ff .ConvertHTML (_aa ,_fff );if _gac !=nil {return nil ,_gac ;};_ebe :=_bb .NewReader (_fae .Data );_cdcd ,_gac :=_fa .NewPdfReader (_ebe );if _gac !=nil {return nil ,_gac ;
};return _cdcd .PageList ,nil ;};var _ff *_cge .Client ;var ErrContentNotDefined =_bd .New ("\u0068\u0074\u006d\u006c\u0020\u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006et\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
var _ _ca .Drawable =(*Document )(nil );type margins struct{Left ,Right ,Bottom ,Top _e .Length ;};

// SetPageWidth sets the page width for given document.
func (_dfd *Document )SetPageWidth (pageWidth _e .Length )error {_dfd ._cdd =pageWidth ;_dfd ._bfd =_ca .PositionAbsolute ;return nil ;};

// WaitVisible waits for the provided selector to be ready.
// A selector might be  i.e.  `#example` for id  and `.example` for classes. The second parameter defines how to match given selector.
func (_deb *Document )WaitVisible (sel string ,by ..._fd .ByType ){_cgg :=_fd .BySearch ;if len (by )> 0{_cgg =by [0];};_deb ._fg =append (_deb ._fg ,_cge .BySelector {Selector :sel ,By :_cgg });};

// Document is HTML document wrapper that is used for extracting and converting HTML document into PDF pages.
type Document struct{_bag _fb .Content ;_a margins ;_bfd _ca .Positioning ;_ae ,_cgd float64 ;_eca _e .PageSize ;_cdd ,_cf _e .Length ;_cfa _e .Orientation ;_cddf bool ;_bfb _bg .Duration ;_cga []_cge .BySelector ;_fg []_cge .BySelector ;_ga *_bg .Duration ;
};func (_gca *Document )validate ()error {if _ff ==nil {return ErrNoClient ;};if _gca ._bag ==nil {return ErrContentNotDefined ;};return nil ;};

// WaitTime sets the waiting time before the webpage is rendered to PDF.
func (_gbg *Document )WaitTime (duration _bg .Duration ){_gbg ._bfb =duration };

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_gbc *Document )SetPos (x ,y float64 ){_gbc ._bfd =_ca .PositionAbsolute ;_gbc ._ae =x ;_gbc ._cgd =y ;};

// SetMarginLeft sets the left margin.
func (_bdg *Document )SetMarginLeft (margin _e .Length ){_bdg ._a .Left =margin };

// SetMarkedContentID sets the marked content id for the document.
func (_bba *Document )SetMarkedContentID (id int64 )*_fa .KDict {return nil };

// WaitReady waits for the provided selector to be ready.
// A selector might be  i.e.  `#example` for id  and `.example` for classes. The second parameter defines how to match given selector.
func (_ebfa *Document )WaitReady (sel string ,by ..._fd .ByType ){_bfe :=_fd .BySearch ;if len (by )> 0{_bfe =by [0];};_ebfa ._cga =append (_ebfa ._cga ,_cge .BySelector {Selector :sel ,By :_bfe });};

// SetMarginTop sets the left margin.
func (_face *Document )SetMarginTop (margin _e .Length ){_face ._a .Top =margin };

// SetMarginBottom sets the left margin.
func (_dg *Document )SetMarginBottom (margin _e .Length ){_dg ._a .Bottom =margin };func _eg (_bca _bf .Image )float64 {_efa :=_bca .Bounds ();var (_dadf int ;_geb _cg .Color ;_faf ,_agc ,_dc uint32 ;);_gb ,_cc :=_efa .Min .X ,_efa .Max .Y -1;_dfb :=_bca .At (_gb ,_cc );
_gdb ,_gfc ,_cdc ,_ :=_dfb .RGBA ();_ad :=_gdb ==_da .MaxUint16 &&_gfc ==_da .MaxUint16 &&_cdc ==_da .MaxUint16 ;for _cc =_efa .Max .Y -1;_cc >=_efa .Min .Y ;_cc --{var _gad bool ;for _gb =_efa .Min .X ;_gb < _efa .Max .X ;_gb ++{_geb =_bca .At (_gb ,_cc );
_faf ,_agc ,_dc ,_ =_geb .RGBA ();if (_ad &&!(_faf ==_gdb &&_agc ==_gfc &&_cdc ==_dc ))||(!_ad &&(_da .Abs (float64 (_faf )-float64 (_gdb ))/float64 (_da .MaxUint16 )> 0.03||_da .Abs (float64 (_agc )-float64 (_gfc ))/float64 (_da .MaxUint16 )> 0.03||_da .Abs (float64 (_dc )-float64 (_cdc ))/float64 (_da .MaxUint16 )> 0.03)){_gad =true ;
break ;};};if _gad {break ;};_dadf =_cc ;};return float64 (_efa .Max .Y -_dadf )/float64 (_efa .Max .Y );};

// TrimLastPageContent trims the last page content so that next creator blocks are located just at the end of given block.
func (_gg *Document )TrimLastPageContent (){_gg ._cddf =true };

// WriteToFile writes the document to a file defined by the output path.
func (_bfc *Document )WriteToFile (outputPath string )error {if _bc :=_bfc .validate ();_bc !=nil {return _bc ;};_cfe :=_bg .Second *20+_bfc ._bfb ;_ged ,_gce :=_f .WithTimeout (_f .Background (),_cfe );defer _gce ();_de ,_df :=_bfc .extract (_ged ,_bfc ._cdd ,_bfc ._cf ,_bfc .getMargins ());
if _df !=nil {return _df ;};_fac :=_ca .New ();for _ ,_baag :=range _de {if _df =_fac .AddPage (_baag );_df !=nil {return _df ;};};return _fac .WriteToFile (outputPath );};

// ConnectOptions creates UniHTML HTTP Client and tries to establish connection with the server.
func ConnectOptions (o Options )error {_ff =_cge .New (_cge .Options {Hostname :o .Hostname ,Port :o .Port ,HTTPS :o .Secure });_baa ,_bdd :=_f .WithTimeout (_f .Background (),_bg .Second *5);defer _bdd ();if _ecd :=_ff .HealthCheck (_baa );_ecd !=nil {return _ecd ;
};return nil ;};

// SetMargins sets the Document Margins.
func (_caa *Document )SetMargins (left ,right ,top ,bottom float64 ){_caa ._a .Left =_e .Point (left );_caa ._a .Right =_e .Point (right );_caa ._a .Top =_e .Point (top );_caa ._a .Bottom =_e .Point (bottom );_caa ._bfd =_ca .PositionAbsolute ;};

// NewDocument creates new HTML Document used as an input for the creator.Drawable.
func NewDocument (path string )(*Document ,error ){_ge :=&Document {};_gf ,_fbg :=_b .Parse (path );if _fbg !=nil {return nil ,_fbg ;};switch _gf .Scheme {case "\u0068\u0074\u0074\u0070","\u0068\u0074\u0074p\u0073":_ge ._bag ,_fbg =_fb .NewWebURL (path );
if _fbg !=nil {return nil ,_fbg ;};return _ge ,nil ;};_be ,_fbg :=_c .Stat (path );if _fbg !=nil {return nil ,_fbg ;};if !_be .IsDir (){_ge ._bag ,_fbg =_fb .NewHTMLFile (path );}else {_ge ._bag ,_fbg =_fb .NewZipDirectory (path );};if _fbg !=nil {return nil ,_fbg ;
};return _ge ,nil ;};