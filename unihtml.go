//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package unihtml contains a plugin for the UniDoc.
package unihtml ;import (_ga "bytes";_e "context";_ea "errors";_f "fmt";_eg "github.com/unidoc/unihtml/client";_b "github.com/unidoc/unihtml/content";_ge "github.com/unidoc/unihtml/selector";_ag "github.com/unidoc/unihtml/sizes";_eab "github.com/unidoc/unipdf/v3/common";
_c "github.com/unidoc/unipdf/v3/common/license";_bg "github.com/unidoc/unipdf/v3/creator";_egd "github.com/unidoc/unipdf/v3/model";_ce "github.com/unidoc/unipdf/v3/render";_g "image";_ab "image/color";_af "math";_a "net/url";_de "os";_fg "time";);func (_ccf *Document )validate ()error {if _cee ==nil {return ErrNoClient ;
};if _ccf ._egf ==nil {return ErrContentNotDefined ;};return nil ;};

// ConnectOptions creates UniHTML HTTP Client and tries to establish connection with the server.
func ConnectOptions (o Options )error {_cee =_eg .New (_eg .Options {Hostname :o .Hostname ,Port :o .Port ,HTTPS :o .Secure });_cd ,_ed :=_e .WithTimeout (_e .Background (),_fg .Second *5);defer _ed ();if _afb :=_cee .HealthCheck (_cd );_afb !=nil {return _afb ;
};return nil ;};func (_gef *Document )extract (_aca _e .Context ,_dcf ,_eacf _ag .Length ,_eae margins )([]*_egd .PdfPage ,error ){_cbc :=_eg .BuildHTMLQuery ().SetContent (_gef ._egf ).PageSize (_gef ._geb ).PaperWidth (_dcf ).PaperHeight (_eacf ).Orientation (_gef ._gg ).MarginLeft (_eae .Left ).MarginRight (_eae .Right ).MarginTop (_eae .Top ).MarginBottom (_eae .Bottom ).TimeoutDuration (_gef .getTimeoutDuration ()).WaitTime (_gef ._egfb );
for _ ,_cf :=range _gef ._ebc {_cbc .WaitReady (_cf .Selector ,_cf .By );};for _ ,_bbc :=range _gef ._dc {_cbc .WaitVisible (_bbc .Selector ,_bbc .By );};_gab ,_ee :=_cbc .Query ();if _ee !=nil {return nil ,_ee ;};var _dfaf _e .CancelFunc ;if _gef ._fae !=nil {_aca ,_dfaf =_e .WithTimeout (_aca ,*_gef ._fae );
}else {_aca ,_dfaf =_e .WithTimeout (_aca ,_fg .Second *15);};defer _dfaf ();_ddg ,_ee :=_cee .ConvertHTML (_aca ,_gab );if _ee !=nil {return nil ,_ee ;};_egb :=_ga .NewReader (_ddg .Data );_dcb ,_ee :=_egd .NewPdfReader (_egb );if _ee !=nil {return nil ,_ee ;
};return _dcb .PageList ,nil ;};

// SetMargins sets the Document Margins.
func (_afd *Document )SetMargins (left ,right ,top ,bottom float64 ){_afd ._gc .Left =_ag .Point (left );_afd ._gc .Right =_ag .Point (right );_afd ._gc .Top =_ag .Point (top );_afd ._gc .Bottom =_ag .Point (bottom );_afd ._daf =_bg .PositionAbsolute ;
};func _aad ()error {_cb :=_c .GetLicenseKey ();if _cb ==nil {return _ea .New ("\u006e\u006f\u0020\u006cic\u0065\u006e\u0073\u0065\u0020\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064");};if !_cb .IsLicensed (){return _ea .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0072 \u006e\u006f\u0020\u006c\u0069\u0063\u0065n\u0073\u0065\u0020\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064");
};return nil ;};

// WaitVisible waits for the provided selector to be ready.
// A selector might be  i.e.  `#example` for id  and `.example` for classes. The second parameter defines how to match given selector.
func (_abfb *Document )WaitVisible (sel string ,by ..._ge .ByType ){_egff :=_ge .BySearch ;if len (by )> 0{_egff =by [0];};_abfb ._dc =append (_abfb ._dc ,_eg .BySelector {Selector :sel ,By :_egff });};

// WaitTime sets the waiting time before the webpage is rendered to PDF.
func (_dd *Document )WaitTime (duration _fg .Duration ){_dd ._egfb =duration };

// ContainerComponent implements creator.containerElement interface.
func (_fbd *Document )ContainerComponent (container _bg .Drawable )(_bg .Drawable ,error ){switch container .(type ){case *_bg .Chapter :default:return nil ,_f .Errorf ("\u0075\u006e\u0069\u0068t\u006d\u006c\u002e\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0063\u006f\u006d\u0070\u006fn\u0065\u006e\u0074\u0020\u006ff\u0020\u0074\u0068\u0065\u0020\u0025\u0054\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072",container );
};return _fbd ,nil ;};

// SetMarginTop sets the left margin.
func (_dae *Document )SetMarginTop (margin _ag .Length ){_dae ._gc .Top =margin };func _aaa (_ac _g .Image )float64 {_eacc :=_ac .Bounds ();var (_dfa int ;_gcg _ab .Color ;_dbbc ,_adb ,_afg uint32 ;);_cea ,_aae :=_eacc .Min .X ,_eacc .Max .Y -1;_bcc :=_ac .At (_cea ,_aae );
_aff ,_aadb ,_egee ,_ :=_bcc .RGBA ();_gcaa :=_aff ==_af .MaxUint16 &&_aadb ==_af .MaxUint16 &&_egee ==_af .MaxUint16 ;for _aae =_eacc .Max .Y -1;_aae >=_eacc .Min .Y ;_aae --{var _age bool ;for _cea =_eacc .Min .X ;_cea < _eacc .Max .X ;_cea ++{_gcg =_ac .At (_cea ,_aae );
_dbbc ,_adb ,_afg ,_ =_gcg .RGBA ();if (_gcaa &&!(_dbbc ==_aff &&_adb ==_aadb &&_egee ==_afg ))||(!_gcaa &&(_af .Abs (float64 (_dbbc )-float64 (_aff ))/float64 (_af .MaxUint16 )> 0.03||_af .Abs (float64 (_adb )-float64 (_aadb ))/float64 (_af .MaxUint16 )> 0.03||_af .Abs (float64 (_afg )-float64 (_egee ))/float64 (_af .MaxUint16 )> 0.03)){_age =true ;
break ;};};if _age {break ;};_dfa =_aae ;};return float64 (_eacc .Max .Y -_dfa )/float64 (_eacc .Max .Y );};func (_eaeb *Document )getTimeoutDuration ()_fg .Duration {if _eaeb ._fae !=nil {return *_eaeb ._fae ;};return 0;};

// GeneratePageBlocks implements creator.Drawable interface.
func (_df *Document )GeneratePageBlocks (ctx _bg .DrawContext )([]*_bg .Block ,_bg .DrawContext ,error ){if _ecg :=_df .validate ();_ecg !=nil {return nil ,ctx ,_ecg ;};var _bc []*_bg .Block ;_cef :=_df .getMargins ();_eca ,_dbb :=_df ._db ,_df ._gca ;
if _df ._daf .IsRelative (){_eca ,_dbb =_ag .Point (ctx .Width ),_ag .Point (ctx .Height );ctx .X -=float64 (_cef .Left .Points ());};_gb ,_bae :=_df .extract (_e .Background (),_eca ,_dbb ,_cef );if _bae !=nil {return nil ,_bg .DrawContext {},_bae ;};
for _geg ,_be :=range _gb {_ebe ,_bca :=_bg .NewBlockFromPage (_be );if _bca !=nil {return nil ,_bg .DrawContext {},_bca ;};var _fe float64 ;if _df ._bd &&_geg ==len (_gb )-1{_ca :=_ce .NewImageDevice ();_agc ,_bf :=_ca .Render (_be );if _bf !=nil {return nil ,_bg .DrawContext {},_bf ;
};_aed ,_bf :=_be .GetMediaBox ();if _bf !=nil {return nil ,_bg .DrawContext {},_bf ;};_abf :=_fg .Now ();_bee :=_aaa (_agc );_fe =_aed .Height ()*_bee ;_eab .Log .Trace ("\u0054\u0072i\u006d\u006d\u0069\u006eg\u0020\u006ca\u0073\u0074\u0020\u0064\u006f\u0063\u0075\u006de\u006e\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0074\u0061\u006b\u0065n\u003a\u0020\u0025\u0076",_fg .Since (_abf ));
if _df ._gc .Bottom !=nil {_fe -=float64 (_df ._gc .Bottom .Points ());};if _fe < 0{_fe =0;};_eab .Log .Trace ("C\u0072\u006f\u0070\u0070\u0069\u006e\u0067\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0027\u0073\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u002e2\u0066 \u0070\u006f\u0069\u006et\u0073\u0020o\u0066\u0066\u0020\u0062\u006f\u0074\u0074\u006f\u006d\u0020\u006f\u0066\u0020\u006d\u0065\u0064\u0069\u0061\u0020\u0062\u006f\u0078\u000a",_fe );
};_aec ,_cc ,_bca :=_ebe .GeneratePageBlocks (ctx );if _bca !=nil {return nil ,_bg .DrawContext {},_bca ;};ctx =_cc ;ctx .Y -=_fe ;if _geg !=len (_gb )-1&&ctx .Y > (ctx .PageHeight -ctx .Margins .Bottom )*.95{ctx .X =ctx .Margins .Left ;ctx .Y =ctx .Margins .Top ;
ctx .Page ++;};_bc =append (_bc ,_aec ...);};return _bc ,ctx ,nil ;};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_aeb *Document )SetPos (x ,y float64 ){_aeb ._daf =_bg .PositionAbsolute ;_aeb ._fa =x ;_aeb ._eb =y ;};

// TrimLastPageContent trims the last page content so that next creator blocks are located just at the end of given block.
func (_cg *Document )TrimLastPageContent (){_cg ._bd =true };type margins struct{Left ,Right ,Bottom ,Top _ag .Length ;};func (_ede *Document )getMargins ()margins {_ef :=_ede ._gc ;if _ede ._daf .IsRelative (){_ef .Top =_ag .Millimeter (1);_ef .Left =_ag .Millimeter (1);
_ef .Bottom =_ag .Millimeter (1);_ef .Right =_ag .Millimeter (1);return _ef ;};if _ef .Top ==nil {_ef .Top =_ag .Millimeter (10);};if _ef .Bottom ==nil {_ef .Bottom =_ag .Millimeter (10);};if _ef .Left ==nil {_ef .Left =_ag .Millimeter (10);};if _ef .Right ==nil {_ef .Right =_ag .Millimeter (10);
};return _ef ;};

// Options are the HTML Client options used for establishing the connection.
type Options struct{

// Hostname defines the hostname for the client. Default value: 'localhost'.
Hostname string ;

// Port defines the port at which the server works. Default value: '8080'
Port int ;

// Secure is the flag that states if the connection uses HTTPS protocol. Default Value: 'false'.
Secure bool ;

// Prefix is an option setting used when the server is working with the URI prefix. Default Value: ''.
Prefix string ;};

// SetTimeoutDuration sets the timeout duration
// the default timeout is 15 seconds.
func (_gcc *Document )SetTimeoutDuration (duration _fg .Duration ){_gcc ._fae =&duration };var ErrContentNotDefined =_ea .New ("\u0068\u0074\u006d\u006c\u0020\u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006et\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");


// WaitReady waits for the provided selector to be ready.
// A selector might be  i.e.  `#example` for id  and `.example` for classes. The second parameter defines how to match given selector.
func (_bdd *Document )WaitReady (sel string ,by ..._ge .ByType ){_faef :=_ge .BySearch ;if len (by )> 0{_faef =by [0];};_bdd ._ebc =append (_bdd ._ebc ,_eg .BySelector {Selector :sel ,By :_faef });};

// NewDocument creates new HTML Document used as an input for the creator.Drawable.
func NewDocument (path string )(*Document ,error ){_bb :=&Document {};_bgc ,_eabf :=_a .Parse (path );if _eabf !=nil {return nil ,_eabf ;};switch _bgc .Scheme {case "\u0068\u0074\u0074\u0070","\u0068\u0074\u0074p\u0073":_bb ._egf ,_eabf =_b .NewWebURL (path );
if _eabf !=nil {return nil ,_eabf ;};return _bb ,nil ;};_ae ,_eabf :=_de .Stat (path );if _eabf !=nil {return nil ,_eabf ;};if !_ae .IsDir (){_bb ._egf ,_eabf =_b .NewHTMLFile (path );}else {_bb ._egf ,_eabf =_b .NewZipDirectory (path );};if _eabf !=nil {return nil ,_eabf ;
};return _bb ,nil ;};

// SetLandscapeOrientation sets document landscape page orientation.
func (_eaf *Document )SetLandscapeOrientation (){_eaf ._gg =_ag .Landscape };

// Connect creates UniHTML HTTP Client and tries to establish connection with the server.
func Connect (path string )error {if _da :=_aad ();_da !=nil {return _da ;};_ad ,_aa :=_eg .ParseOptions (path );if _aa !=nil {return _aa ;};_cee =_eg .New (_ad );_ceg ,_fc :=_e .WithTimeout (_e .Background (),_fg .Second *5);defer _fc ();if _ba :=_cee .HealthCheck (_ceg );
_ba !=nil {return _ba ;};return nil ;};

// WriteToFile writes the document to a file defined by the output path.
func (_dbd *Document )WriteToFile (outputPath string )error {if _adf :=_dbd .validate ();_adf !=nil {return _adf ;};_fcf :=_fg .Second *20+_dbd ._egfb ;_ecd ,_fcfd :=_e .WithTimeout (_e .Background (),_fcf );defer _fcfd ();_fb ,_faa :=_dbd .extract (_ecd ,_dbd ._db ,_dbd ._gca ,_dbd .getMargins ());
if _faa !=nil {return _faa ;};_ege :=_bg .New ();for _ ,_dbg :=range _fb {if _faa =_ege .AddPage (_dbg );_faa !=nil {return _faa ;};};return _ege .WriteToFile (outputPath );};var ErrNoClient =_ea .New ("\u0055n\u0069\u0048\u0054\u004d\u004c\u0020\u0063\u006c\u0069\u0065\u006et\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");


// Document is HTML document wrapper that is used for extracting and converting HTML document into PDF pages.
type Document struct{_egf _b .Content ;_gc margins ;_daf _bg .Positioning ;_fa ,_eb float64 ;_geb _ag .PageSize ;_db ,_gca _ag .Length ;_gg _ag .Orientation ;_bd bool ;_egfb _fg .Duration ;_ebc []_eg .BySelector ;_dc []_eg .BySelector ;_fae *_fg .Duration ;
};

// SetPageWidth sets the page width for given document.
func (_cbf *Document )SetPageWidth (pageWidth _ag .Length )error {_cbf ._db =pageWidth ;_cbf ._daf =_bg .PositionAbsolute ;return nil ;};

// SetMarginRight sets the left margin.
func (_fcb *Document )SetMarginRight (margin _ag .Length ){_fcb ._gc .Right =margin };

// SetPageSize sets the page default size.
func (_gcgg *Document )SetPageSize (pageSize _ag .PageSize )error {if !pageSize .IsAPageSize (){return _ea .New ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0070\u0061\u0067\u0065\u0020s\u0069\u007a\u0065");
};_gcgg ._geb =pageSize ;_gcgg ._daf =_bg .PositionAbsolute ;return nil ;};

// GetPdfPages is a function that converts provided input content and
func (_fgb *Document )GetPdfPages (ctx _e .Context )([]*_egd .PdfPage ,error ){if _eac :=_fgb .validate ();_eac !=nil {return nil ,_eac ;};return _fgb .extract (ctx ,_fgb ._db ,_fgb ._gca ,_fgb .getMargins ());};

// SetPageHeight sets the page height for given document.
func (_eda *Document )SetPageHeight (pageHeight _ag .Length )error {_eda ._gca =pageHeight ;_eda ._daf =_bg .PositionAbsolute ;return nil ;};var _ _bg .Drawable =(*Document )(nil );var _cee *_eg .Client ;

// SetMarginLeft sets the left margin.
func (_gga *Document )SetMarginLeft (margin _ag .Length ){_gga ._gc .Left =margin };

// SetMarginBottom sets the left margin.
func (_gcb *Document )SetMarginBottom (margin _ag .Length ){_gcb ._gc .Bottom =margin };